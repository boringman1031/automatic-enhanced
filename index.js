// index.js
import fs from "fs";
import path from "path";
import mammoth from "mammoth";
import puppeteer from "puppeteer";
import yargs from "yargs";
import { hideBin } from "yargs/helpers";
import readline from "readline";

// ---------- CLI ----------
const argv = yargs(hideBin(process.argv))
  .option("mode", { type: "string", default: "task+card", describe: "task | card | task+card" })
  .option("word", { type: "string", describe: "Word Ê™îË∑ØÂæëÔºà.docxÔºâ" })
  .option("loop", { type: "boolean", default: false })
  .option("close", { type: "boolean", default: false })
  .option("url", { type: "string", describe: "ÔºàÂèØÈÅ∏ÔºâËá™ÂãïÂâçÂæÄ„ÄéÂª∫Á´ã‰ªªÂãô„ÄèÈ†Å URL" })
  .help().argv;

console.log("‚öôÔ∏è argv =", argv);

// ---------- mapping ----------
let mapping = {};
try {
  mapping = JSON.parse(fs.readFileSync("./mapping.json", "utf8"));
  if (!mapping.task) mapping.task = {};
  if (!mapping.card) mapping.card = {};
  console.log("üìë Â∑≤ËºâÂÖ• mapping.json");
} catch (e) {
  console.error("‚ùå Êâæ‰∏çÂà∞ mapping.json Êàñ JSON ÊêçÂ£û");
  process.exit(1);
}

// ---------- Â∞èÂ∑•ÂÖ∑ ----------
function ask(prompt = "") {
  const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
  return new Promise((resolve) => rl.question(prompt, (ans) => { rl.close(); resolve(ans); }));
}

function cssEscape(s) {
  return String(s).replace(/["\\]/g, "\\$&");
}

function preview(s, n = 36) {
  const t = (s || "").replace(/\s+/g, " ").trim();
  return t.length > n ? t.slice(0, n) + "..." : t;
}

// ÂÉÖÂÅöËºïÈáèÊ∏ÖÁêÜÔºö‰øùÁïô $[[...]]ÔºåÁ†çÁ©∫ÁôΩ/È†ÅÁ¢º/Á≥ªÁµ±ÊÆµ
function pruneAfterMarkers(text) {
  const markers = ["„ÄêÁ≥ªÁµ±„Äë", "Áü•Ë≠òÂç°ÂàÜÈ°û", "Á¨¨‰∏ÄÁµÑÁü•Ë≠òÂç°", "Á¨¨‰∫åÁµÑÁü•Ë≠òÂç°", "Á¨¨‰∏âÁµÑÁü•Ë≠òÂç°"];
  let cut = text.length;
  for (const m of markers) {
    const i = text.indexOf(m);
    if (i !== -1) cut = Math.min(cut, i);
  }
  return text.slice(0, cut);
}

function cleanTextBase(text) {
  let t = String(text);
  t = t.split("\n").filter(l => !/^\d+$/.test(l.trim())).join("\n");
  t = pruneAfterMarkers(t);
  return t.trim();
}

// Âè™Â∞ç description/answerDescription/cardDescription Áî®ÁöÑÊ∏ÖÁêÜ
function stripBracketNotesBlock(s) {
  if (!s) return s;
  const lines = String(s).split(/\r?\n/);
  const out = [];
  let firstKeptSeen = false;

  // Ëã•Â∞á‰æÜÁôºÁèæÂÖ∂ÂÆÉË¢´Êç≤ÈÄ≤‰æÜÁöÑÂ∞èÊ®ôÈ°åÔºåÂèØÊì¥ÂÖÖÈÄôÂÄã RE
  const neighborHeadingsRE = /^(Â§öÂ™íÈ´îË£úÂÖÖË≥áË®ä|Âõ†ÊùêÁ∂≤ÊàñÂ§ñÈÉ®Ë≥áË®ä|Âç°ÁâáÂúñÁâá|Á∑®ËºØËÄÖË®ªËß£|Âç°ÁâáÁ∑öÁ¥¢Ë™™Êòé)\s*$/;

  for (let line of lines) {
    const trimmed = line.trim();

    // Êï¥Ë°åÂè™ÊúâÊã¨ÂºßË™™Êòé -> ‰∏üÊéâ
    if (/^[Ôºà(][^Ôºâ)]+[Ôºâ)]$/.test(trimmed)) continue;

    // Á¨¨‰∏ÄÊÆµËã•‰ª•Êã¨ÂºßË™™ÊòéËµ∑È†≠ÔºåÂÉÖÂâùÊéâÈÄôÊÆµÁöÑÂâçÂ∞éÊã¨ÂºßÔºå‰øùÁïôÂæåÈù¢Ê≠£Êñá
    if (!firstKeptSeen && /^[Ôºà(][^Ôºâ)]+[Ôºâ)]/.test(trimmed)) {
      line = line.replace(/^[Ôºà(][^Ôºâ)]+[Ôºâ)]\s*/, "");
    }

    // Ë¢´Ë™§Êç≤ÁöÑÂ∞èÊ®ôÈ°å -> ‰∏üÊéâ
    if (neighborHeadingsRE.test(trimmed)) continue;

    if (line.trim().length && !firstKeptSeen) firstKeptSeen = true;
    out.push(line);
  }
  return out.join("\n").trim();
}

function firstLine(text) {
  return (String(text).split("\n").find(l => l.trim().length) || "").trim();
}

// ---------- Ëß£Êûê Word ----------
// ‰ªªÂãôÊ¨Ñ‰ΩçÔºàÁî® mapping.task ÁöÑ key ÊäìÊÆµËêΩÔºâ
async function parseTaskSections(value) {
  const titles = new Set(Object.keys(mapping.task || {}));
  const resultRaw = {};
  let curKey = null;

  for (const raw of value.split("\n")) {
    const line = raw.trim();
    if (!line) continue;
    if (titles.has(line)) {
      curKey = line;
      resultRaw[curKey] = "";
    } else if (curKey) {
      resultRaw[curKey] += (resultRaw[curKey] ? "\n" : "") + line;
    }
  }

  const taskData = {};
  for (const [title, cfg] of Object.entries(mapping.task)) {
    const name = typeof cfg === "string" ? cfg : cfg.name;
    if (!name || !resultRaw[title]) continue;
    let v = cleanTextBase(resultRaw[title]);

    // ‰ªªÂãôÁöÑÂñÆË°åÊ¨Ñ‰Ωç
    if (["name", "syllabus", "area", "centuryId", "mainSubjectId", "level"].includes(name)) {
      v = firstLine(v);
    }
    if (name.startsWith("missionHintSet")) {
      v = v.split("\n").map(s => s.replace(/ÔºàÈôê25Â≠ó[^Ôºâ]*Ôºâ/g, "").trim()).filter(Boolean)[0] || "";
    }

    // Âè™Â∞çÈÄôÂÖ©ÂÄãÊ¨Ñ‰ΩçÂâùÊã¨ÂºßÂÇôË®ª/Â∞èÊ®ôÈ°å
    if (name === "description" || name === "answerDescription") {
      v = stripBracketNotesBlock(v);
    }

    taskData[name] = v.trim();
  }
  return taskData;
}

// Âç°ÁâáÊ¨Ñ‰ΩçÔºàÊåâ label Âæ™Â∫èÂàáÂç°Ôºâ
function parseCards(value) {
  const labels = mapping.__cardLabels || ["Âç°ÁâáÂêçÁ®±", "ÊñáÂ≠óÂÖßÂÆπ", "Â≠∏Áßë", "È°ûÂà•", "Ë™≤Á∂±"];
  const labelToKey = {
    "Âç°ÁâáÂêçÁ®±": "cardTitle",
    "ÊñáÂ≠óÂÖßÂÆπ": "cardDescription",
    "Â≠∏Áßë": "cardSubjectId",
    "È°ûÂà•": "cardType",
    "Ë™≤Á∂±": "cardSyllabus"
  };

  const lines = value.split("\n").map(s => s.trim()).filter(Boolean);
  const cards = [];
  let cur = null;
  let curField = null;

  for (const line of lines) {
    if (labels.includes(line)) {
      // Êñ∞Âç°ÁâáÈñãÂßãÔºöÈÅáÂà∞‰∏ã‰∏ÄÂÄã„ÄåÂç°ÁâáÂêçÁ®±„Äç
      if (line === "Âç°ÁâáÂêçÁ®±") {
        if (cur && (cur.cardTitle || cur.cardDescription)) {
          cards.push(cur);
        }
        cur = {};
      }
      curField = labelToKey[line] || null;
      continue;
    }
    if (curField && cur) {
      cur[curField] = (cur[curField] ? cur[curField] + "\n" : "") + line;
    }
  }
  if (cur && (cur.cardTitle || cur.cardDescription)) {
    cards.push(cur);
  }

  // Ê≠£Ë¶èÂåñÔºöÂêçÁ®±ÂèñÁ¨¨‰∏ÄË°åÔºõÂÖßÂÆπÊ∏ÖÁêÜÔºõÔºà‰∏çÂÜçËôïÁêÜÂ≠∏Áßë/È°ûÂà•Ôºâ
  for (const c of cards) {
    if (c.cardTitle) c.cardTitle = firstLine(c.cardTitle);
    if (c.cardDescription) {
      let cleaned = stripBracketNotesBlock(cleanTextBase(c.cardDescription));
      cleaned = cleaned.split("\n").map(s => s.trim()).filter(Boolean)[0] || ""; // Âè™ÂèñÁ¨¨‰∏ÄÂÄãÈùûÁ©∫Ë°å
      c.cardDescription = cleaned;
    }
    // if (c.cardSubjectId) c.cardSubjectId = firstLine(c.cardSubjectId);
    // if (c.cardType)      c.cardType      = firstLine(c.cardType);
  }

  // Âõ∫ÂÆöÂè™Âèñ 12 Âºµ
  return cards.slice(0, 12);
}

async function parseWord(wordPath) {
  const { value } = await mammoth.extractRawText({ path: wordPath });
  const taskData = await parseTaskSections(value);
  const cardDataList = parseCards(value);
  return { taskData, cardDataList };
}

// ---------- DOM ÂØ´ÂÖ• ----------
async function setByNameNative(page, name, value) {
  const selector = `[name="${cssEscape(name)}"]`;
  return page.evaluate((sel, val) => {
    const el = document.querySelector(sel);
    if (!el) return "NF";
    const isTA = el.tagName.toLowerCase() === "textarea";
    const proto = isTA ? HTMLTextAreaElement.prototype : HTMLInputElement.prototype;
    const desc = Object.getOwnPropertyDescriptor(proto, "value");
    if (!desc || !desc.set) return "NOSETTER";
    el.focus();
    desc.set.call(el, val);
    el.dispatchEvent(new Event("input", { bubbles: true }));
    el.dispatchEvent(new Event("change", { bubbles: true }));
    el.blur();
    return "OK";
  }, selector, value);
}

async function typeIntoInputByLabel(page, labelText, value) {
  return page.evaluate((label, val) => {
    const lab = Array.from(document.querySelectorAll("label,div,span,p,h6,h5"))
      .find(el => (el.textContent || "").trim() === label);
    const row = lab ? lab.closest(".MuiGrid-root, .MuiStack-root, div") : null;
    const input = row ? row.querySelector('input[type="text"], input:not([type]), textarea') : null;
    if (!input) return "NF";

    const isTA = input.tagName.toLowerCase() === "textarea";
    const proto = isTA ? HTMLTextAreaElement.prototype : HTMLInputElement.prototype;
    const desc = Object.getOwnPropertyDescriptor(proto, "value");
    if (!desc || !desc.set) return "NOSETTER";
    input.focus();
    desc.set.call(input, val);
    input.dispatchEvent(new Event("input", { bubbles: true }));
    input.dispatchEvent(new Event("change", { bubbles: true }));
    input.blur();
    return "OK";
  }, labelText, value);
}

async function typeIntoRichByLabel(page, labelText, value) {
  return page.evaluate((label, val) => {
    const lab = Array.from(document.querySelectorAll("label,div,span,p,h6,h5"))
      .find(el => (el.textContent || "").trim() === label);
    const row = lab ? lab.closest(".MuiGrid-root, .MuiStack-root, div") : null;
    let box =
      (row && row.querySelector("textarea")) ||
      (row && row.querySelector('[contenteditable="true"]')) ||
      (row && row.querySelector(".ql-editor")) ||
      (row && row.querySelector('[role="textbox"]'));
    if (!box) return "NF";

    if (box.tagName && box.tagName.toLowerCase() === "textarea") {
      const desc = Object.getOwnPropertyDescriptor(HTMLTextAreaElement.prototype, "value");
      box.focus();
      desc.set.call(box, val);
      box.dispatchEvent(new Event("input", { bubbles: true }));
      box.dispatchEvent(new Event("change", { bubbles: true }));
      box.blur();
      return "OK";
    }

    box.focus();
    const sel = window.getSelection();
    const range = document.createRange();
    range.selectNodeContents(box);
    sel.removeAllRanges();
    sel.addRange(range);
    document.execCommand("delete", false, null);
    document.execCommand("insertText", false, val);
    box.dispatchEvent(new InputEvent("input", { bubbles: true, data: val }));
    box.dispatchEvent(new Event("change", { bubbles: true }));
    return "OK";
  }, labelText, value);
}

// ---------- ‰ªªÂãôÈ†ÅÂ°´ÂØ´ ----------
async function waitForTaskReady(page) {
  try {
    await page.waitForSelector('[name="description"], [name="name"]', { timeout: 5000 });
  } catch {}
}

async function fillTask(page, taskData) {
  console.log("‚úçÔ∏è ‰ªªÂãôÈ†ÅÈñãÂßãÂ°´ÂØ´...");
  await waitForTaskReady(page);

  for (const [title, cfg] of Object.entries(mapping.task)) {
    const name = typeof cfg === "string" ? cfg : cfg.name;
    const isRich = !!(typeof cfg === "object" && cfg.rich);
    const labels = (typeof cfg === "object" && cfg.label) ? cfg.label : [title];
    const val = taskData[name];
    if (!val) continue;

    let done = false;
    // ÂÖàË©¶ name
    const r1 = await setByNameNative(page, name, val);
    if (r1 === "OK") { done = true; }
    // ÂØåÊñáÊú¨ÂÇôÊè¥
    if (!done && isRich) {
      for (const lb of labels) {
        const r2 = await typeIntoRichByLabel(page, lb, val);
        if (r2 === "OK") { done = true; break; }
      }
    }
    console.log(done ? `‚úÖ ${name}: ${preview(val)}` : `‚ö†Ô∏è Êâæ‰∏çÂà∞Ê¨Ñ‰Ωç: ${name}`);
  }

  console.log("üéâ ‰ªªÂãôÈ†ÅÂÆåÊàêÔºÅ");
}

// ---------- Âç°ÁâáÈ†ÅÂ°´ÂØ´ÔºàÂÉÖÊ®ôÈ°åËàáÊñáÂ≠óÂÖßÂÆπÔºâ ----------
async function fillOneCard(page, card, index) {
  const title = card.cardTitle || "";
  const desc  = card.cardDescription || "";

  // Âç°ÁâáÂêçÁ®±ÔºàÂñÆË°åÔºâ
  if (title) {
    const r = await typeIntoInputByLabel(page, "Âç°ÁâáÂêçÁ®±", title);
    console.log(r === "OK" ? `‚úÖ cardTitle: ${preview(title)}` : "‚ö†Ô∏è Êâæ‰∏çÂà∞„ÄéÂç°ÁâáÂêçÁ®±„ÄèËº∏ÂÖ•Ê°Ü");
  }

  // ÊñáÂ≠óÂÖßÂÆπÔºàÂ§öË°å/textarea/contenteditable ÈÉΩÂèØÔºâ
  if (desc) {
    const r = await typeIntoRichByLabel(page, "ÊñáÂ≠óÂÖßÂÆπ", desc);
    console.log(r === "OK" ? `‚úÖ cardDescription: ${preview(desc)}` : "‚ö†Ô∏è Êâæ‰∏çÂà∞„ÄéÊñáÂ≠óÂÖßÂÆπ„ÄèËº∏ÂÖ•Ê°Ü");
  }
}

// ---------- ‰∏äÂÇ≥ÂúñÁâáË¶ñÁ™óÔºöÂÖ©Ê¨Ñ‰ΩçËá™ÂãïÂ°´ ----------
// ---------- Âú®Â∞çË©±Ê°Ü‰∏≠Â°´ÂÖ•ÊêúÂ∞ãÂ≠ó‰∏≤ÔºàÊêúÂ∞ãÁèæÊúâÂúñÁâáÁî®Ôºâ ----------
async function typeIntoFirstTextInputInDialog(page, value) {
  return page.evaluate((val) => {
    const dialogs = document.querySelectorAll('[role="dialog"]');
    const dialog = dialogs[dialogs.length - 1];
    if (!dialog) return 'NODIALOG';

    // Áõ°ÈáèÊâæÁ¨¨‰∏ÄÂÄãÂèØË¶ãÁöÑÊñáÂ≠óËº∏ÂÖ•Ê°ÜÔºàÂê´ MUI„ÄÅ‰∏ÄËà¨ input„ÄÅrole=textboxÔºâ
    const candidates = Array.from(dialog.querySelectorAll(
      'input[type="text"], input:not([type]), [role="textbox"]'
    )).filter(el => {
      const style = window.getComputedStyle(el);
      return style && style.display !== 'none' && style.visibility !== 'hidden';
    });

    const input = candidates[0];
    if (!input) return 'NF';

    // ÂÑ™ÂÖàÁî®ÂéüÁîü setterÔºåÁ¢∫‰øù React/MUI ËÉΩÊî∂Âà∞‰∫ã‰ª∂
    if (input.tagName.toLowerCase() === 'input') {
      const desc = Object.getOwnPropertyDescriptor(HTMLInputElement.prototype, 'value');
      input.focus();
      desc.set.call(input, val);
      input.dispatchEvent(new Event('input', { bubbles: true }));
      input.dispatchEvent(new Event('change', { bubbles: true }));
      input.blur();
      return 'OK';
    }

    // ÂØåÊñáÊú¨/role=textbox ÁöÑÂÇôÊè¥
    input.focus();
    const sel = window.getSelection();
    const range = document.createRange();
    range.selectNodeContents(input);
    sel.removeAllRanges();
    sel.addRange(range);
    document.execCommand('delete', false, null);
    document.execCommand('insertText', false, val);
    input.dispatchEvent(new InputEvent('input', { bubbles: true, data: val }));
    input.dispatchEvent(new Event('change', { bubbles: true }));
    return 'OK';
  }, value);
}

// ÊâìÈñã„ÄäÊêúÂ∞ãÁèæÊúâÂúñÁâá„ÄãÂæåÔºåÊääÂç°ÁâáÂêçÁ®±Ë≤ºÂà∞ÊêúÂ∞ãÊ°Ü
async function fillSearchExistingImageDialog(page, query) {
  await getTopDialog(page); // Á≠âÊêúÂ∞ãË¶ñÁ™óÂá∫Áèæ
  const r = await typeIntoFirstTextInputInDialog(page, query || '');
  console.log('üîé ÊêúÂ∞ãÈóúÈçµÂ≠ó:', r, '‚Üí', (query || '').slice(0, 24));
}
async function getTopDialog(page) {
  await page.waitForSelector('[role="dialog"]', { timeout: 8000 });
  return page.$$('[role="dialog"]').then(list => list[list.length - 1]);
}

async function typeIntoInputByLabelInDialog(page, labelText, value) {
  return page.evaluate((label, val) => {
    const dialogs = document.querySelectorAll('[role="dialog"]');
    const dialog = dialogs[dialogs.length - 1];
    if (!dialog) return 'NODIALOG';

    const lab = Array.from(dialog.querySelectorAll('label,div,span,p,h6,h5'))
      .find(el => (el.textContent || '').trim() === label);
    const row = lab ? lab.closest('.MuiGrid-root, .MuiStack-root, div') : null;
    const input = row ? row.querySelector('input[type="text"], input:not([type])') : null;
    if (!input) return 'NF';

    const desc = Object.getOwnPropertyDescriptor(HTMLInputElement.prototype, 'value');
    input.focus();
    desc.set.call(input, val);
    input.dispatchEvent(new Event('input', { bubbles: true }));
    input.dispatchEvent(new Event('change', { bubbles: true }));
    input.blur();
    return 'OK';
  }, labelText, value);
}

async function typeIntoTextareaByLabelInDialog(page, labelText, value) {
  return page.evaluate((label, val) => {
    const dialogs = document.querySelectorAll('[role="dialog"]');
    const dialog = dialogs[dialogs.length - 1];
    if (!dialog) return 'NODIALOG';

    const lab = Array.from(dialog.querySelectorAll('label,div,span,p,h6,h5'))
      .find(el => (el.textContent || '').trim() === label);
    const row = lab ? lab.closest('.MuiGrid-root, .MuiStack-root, div') : null;
    const box = row && (row.querySelector('textarea') ||
                        row.querySelector('[contenteditable="true"]') ||
                        row.querySelector('.ql-editor') ||
                        row.querySelector('[role="textbox"]'));
    if (!box) return 'NF';

    if (box.tagName && box.tagName.toLowerCase() === 'textarea') {
      const desc = Object.getOwnPropertyDescriptor(HTMLTextAreaElement.prototype, 'value');
      box.focus();
      desc.set.call(box, val);
      box.dispatchEvent(new Event('input', { bubbles: true }));
      box.dispatchEvent(new Event('change', { bubbles: true }));
      box.blur();
      return 'OK';
    }

    box.focus();
    const sel = window.getSelection();
    const range = document.createRange();
    range.selectNodeContents(box);
    sel.removeAllRanges();
    sel.addRange(range);
    document.execCommand('delete', false, null);
    document.execCommand('insertText', false, val);
    box.dispatchEvent(new InputEvent('input', { bubbles: true, data: val }));
    box.dispatchEvent(new Event('change', { bubbles: true }));
    return 'OK';
  }, labelText, value);
}

async function fillUploadImageDialog(page, title, description) {
  await getTopDialog(page); // Á≠âË¶ñÁ™óÂá∫Áèæ
  const r1 = await typeIntoInputByLabelInDialog(page, 'ÂúñÁâáÂêçÁ®±', title || '');
  const r2 = await typeIntoTextareaByLabelInDialog(page, 'ÂúñÁâáÊèèËø∞', description || '');
  console.log('üñº ÂúñÁâáÂêçÁ®±:', r1, 'ÂúñÁâáÊèèËø∞:', r2);

  // Ëã•Ë¶ÅËá™ÂãïÈÄÅÂá∫ÔºåËß£Èô§Ë®ªËß£Âç≥ÂèØ
  // await page.evaluate(() => {
  //   const btn = Array.from(document.querySelectorAll('[role="dialog"] button, [role="dialog"] [role="button"]'))
  //     .find(b => /Á¢∫ÂÆö‰∏äÂÇ≥/.test((b.textContent || '')));
  //   btn?.click();
  // });
}

// ---------- ÊµÅÁ®ã ----------
async function runOnce(page, wordPath) {
  if (argv.url) {
    try { await page.goto(argv.url, { waitUntil: "domcontentloaded", timeout: 60000 }); }
    catch (e) { console.log("‚ö†Ô∏è Ëá™ÂãïÈñãÂïü URL Â§±ÊïóÔºåË´ãÊâãÂãïÂàáÈ†ÅÔºö", e.message); }
  }

  if (!wordPath) { console.error("‚ùå ÈúÄÊèê‰æõ --word"); return; }

  console.log("üìÇ Ëß£Êûê Word:", wordPath);
  const { taskData, cardDataList } = await parseWord(wordPath);

  // ‰ªªÂãôÈ†Å
  await ask("üëâ Ë´ãÂàáÂà∞„ÄéÂª∫Á´ã‰ªªÂãô„ÄèÈ†ÅÔºàÈúÄÁôªÂÖ•Ôºâ„ÄÇÊ∫ñÂÇôÂ•ΩÊåâ Enter ÈñãÂßãÂ°´...");
  await fillTask(await getActivePage(page), taskData);

  if (argv.mode === "task") return;

  // Âç°ÁâáÈ†ÅÔºàÂõ∫ÂÆö 12 ÂºµÔºâ
  const cards = cardDataList;
  for (let i = 0; i < cards.length; i++) {
    const tag = `${Math.floor(i/4) + 1}-${(i % 4) + 1}`; // 1-1..3-4

    // 1) Â°´Âç°Áâá
    await ask(`üëâ Ë´ãÂàáÂà∞„ÄéÂç°ÁâáÊ®°Âºè„ÄèÈ†ÅÔºàÁõÆÂâçË¶ÅÂ°´Ôºö${tag}Ôºâ„ÄÇÊ∫ñÂÇôÂ•ΩÂæåÊåâ Enter ÈñãÂßã...`);
    await fillOneCard(await getActivePage(page), cards[i], i);

    // 2) „ÄêÊñ∞Â¢û„ÄëÂú®‰∏äÂÇ≥ÂúñÁâáÂâçÔºåÂÖàÈñã„ÄéÊêúÂ∞ãÁèæÊúâÂúñÁâá„ÄèË¶ñÁ™óÔºåË≤º‰∏äÂç°ÁâáÂêçÁ®±Âà∞ÊêúÂ∞ãÊ°Ü
    const keyword = cards[i].cardTitle || '';
    await ask('üëâ Ë´ãÂú®Âç°ÁâáÈ†ÅÊåâ„ÄêÊêúÂ∞ãÁèæÊúâÂúñÁâá„ÄëÊâìÈñãË¶ñÁ™óÔºåÊ∫ñÂÇôÂ•ΩÂæåÊåâ EnterÔºåÊàëÊúÉË≤º‰∏äÊêúÂ∞ãÈóúÈçµÂ≠ó...');
    await fillSearchExistingImageDialog(await getActivePage(page), keyword);
    console.log('‚úÖ Â∑≤Ë≤º‰∏äÊêúÂ∞ãÈóúÈçµÂ≠óÔºàÂç°ÁâáÂêçÁ®±ÔºâÂà∞ÊêúÂ∞ãÊ°Ü');

    // Ôºà‰Ω†ÂèØ‰ª•ÈÅ∏ÊìáÂú®ÈÄôË£°Êö´ÂÅúÔºåËÆì‰Ω†Ëá™Â∑±Êåâ„ÄåÊêúÂ∞ã„ÄçÊàñÊåëÂúñÔºâ
    // await ask('üëâ Â¶ÇÈúÄÈ¶¨‰∏äÊêúÂ∞ãÔºåË´ãÊâãÂãïÊåâ„ÄåÊêúÂ∞ã„ÄçÊàñËº∏ÂÖ•Ê≥ï Enter„ÄÇÊåëÂ•ΩÂúñÂæåÊåâ Enter ÁπºÁ∫å‰∏äÂÇ≥ÂúñÁâáÊ≠•È©ü...');

    // 3) ‰∏äÂÇ≥ÂúñÁâáË¶ñÁ™óÔºàÂéüÊú¨Â∞±ÊúâÁöÑÊ≠•È©üÔºâ
    await ask('üëâ Ë´ãÂú®Âç°ÁâáÈ†ÅÊåâ„Äê‰∏äÂÇ≥ÂúñÁâá„ÄëÊâìÈñãË¶ñÁ™óÔºåÊ∫ñÂÇôÂ•ΩÂæåÊåâ Enter ÁπºÁ∫å...');
    await fillUploadImageDialog(await getActivePage(page), cards[i].cardTitle, cards[i].cardDescription);
  }

  console.log("‚úÖ ÂÖ®ÈÉ®Âç°ÁâáËôïÁêÜÂÆåÁï¢ÔºÅ");
}

async function getActivePage(page) {
  const pages = await page.browser().pages();
  const active = pages[pages.length - 1];
  await active.bringToFront();
  return active;
}

// ---------- Windows ChromeÔºà‰øùÁïôÔºâ ----------
function getWindowsChromePath() {
  if (process.platform !== "win32") return undefined;
  const cand = [
    path.join(process.env["PROGRAMFILES"] || "", "Google/Chrome/Application/chrome.exe"),
    path.join(process.env["PROGRAMFILES(X86)"] || "", "Google/Chrome/Application/chrome.exe"),
    path.join(process.env["LOCALAPPDATA"] || "", "Google/Chrome/Application/chrome.exe"),
    path.join(process.env["PROGRAMFILES"] || "", "Microsoft/Edge/Application/msedge.exe"),
    path.join(process.env["PROGRAMFILES(X86)"] || "", "Microsoft/Edge/Application/msedge.exe"),
  ].filter(Boolean);
  return cand.find(p => fs.existsSync(p));
}

// ---------- Main ----------
async function main() {
  console.log("üöÄ ÈÄ≤ÂÖ• main()");
  const userDataDir = path.resolve("./user_data");
  if (!fs.existsSync(userDataDir)) fs.mkdirSync(userDataDir, { recursive: true });

  const execPath = getWindowsChromePath();

  const browser = await puppeteer.launch({
    headless: false,
    defaultViewport: null,
    userDataDir,
    executablePath: execPath,
    args: ["--disable-features=ImprovedKeyboardShortcuts", "--no-sandbox"],
  });

  const [page] = await browser.pages();

  // ÂïüÂãïÊôÇËá™ÂãïÂâçÂæÄÊåáÂÆöÁ∂≤ÂùÄ
  await page.goto("https://adl.edu.tw/twa-admin/edit/missionEdit", { waitUntil: "domcontentloaded" });

  if (!argv.word) {
    console.error("‚ùå Ë´ãÊèê‰æõ --word");
    if (argv.close) await browser.close();
    process.exit(1);
  }

  // ÂÖàË∑ëÁ¨¨‰∏ÄÂÄãÊ™îÊ°àÔºàÂøÖË¶ÅÔºâ
  await runOnce(page, argv.word);

  // Ëã•ÈñãÂïü --loopÔºåÊåÅÁ∫åË©¢Âïè‰∏ã‰∏ÄÂÄãÊ™îÊ°àË∑ØÂæë
  if (argv.loop) {
    while (true) {
      const next = (await ask("üìÑ Ë´ãËº∏ÂÖ•‰∏ã‰∏ÄÂÄã Word Ê™îË∑ØÂæëÔºàÁõ¥Êé• Enter ÁµêÊùüÔºâÔºö")).trim();
      if (!next) break;
      await runOnce(await getActivePage(page), next);
    }
  }

  if (argv.close) {
    await browser.close();
    console.log("‚úÖ ÈóúÈñâÁÄèË¶ΩÂô®ÔºåÁ®ãÂºèÁµêÊùü");
  } else {
    console.log("‚úÖ ÊµÅÁ®ãÂÆåÊàêÔºåÁÄèË¶ΩÂô®‰øùÊåÅÈñãËëóÔºàÊ≤øÁî®ÁôªÂÖ•Ôºâ„ÄÇ");
  }
}

main().catch((err) => {
  console.error("‚ùå Âü∑Ë°åÈåØË™§:", err);
});
